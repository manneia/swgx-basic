# 发票状态同步优化方案

## 问题描述

原有的 `syncUnaccountedInvoices` 方法在处理近2万张发票时，需要调用2万次全量发票查询接口，效率极低。

## 优化策略

### 旧方案（逐个查询）
```
对于每张发票：
  1. 调用全量发票查询接口（单张）
  2. 比对状态
  3. 更新数据库
  
总API调用次数 = 发票数量（20,000次）
```

### 新方案（批量查询）
```
1. 从数据库查询所有需要同步的发票
2. 按纳税人分组
3. 对每个纳税人：
   - 批量查询该纳税人的所有发票（分页）
   - 建立发票映射表（发票代码+号码 -> 发票对象）
4. 遍历数据库记录，从映射表中查找对应发票
5. 比对状态并更新

总API调用次数 = 纳税人数量 × 分页次数（约 9 × 10 = 90次）
```

## 性能提升

假设：
- 发票总数：20,000张
- 纳税人数量：9个
- 每个纳税人平均发票数：2,222张
- 每页大小：200条
- 每个纳税人平均分页数：12页

### 旧方案
- API调用次数：20,000次
- 预计耗时：20,000 × 0.5秒 = 10,000秒 ≈ 2.8小时

### 新方案
- API调用次数：9 × 12 = 108次
- 预计耗时：108 × 0.5秒 = 54秒

**性能提升：约 185倍**

## 使用方法

### 方法1：使用优化版本（推荐）
```java
// 已自动切换到优化版本
invoiceCollectionService.syncUnaccountedInvoices();
```

### 方法2：使用旧版本（备用）
```java
// 如果需要使用旧版本
invoiceCollectionService.syncUnaccountedInvoicesOld();
```

## 实现细节

### 核心方法

1. **syncInvoicesByEntryStatusOptimized**
   - 主要优化逻辑
   - 批量查询 + 内存比对

2. **queryFullInvoicesByTaxpayer**
   - 查询单个纳税人的所有发票
   - 自动处理分页

### 数据结构

```java
// 发票映射表
Map<String, InvoiceFullItemDTO> fullInvoiceMap
// Key: 发票代码_发票号码
// Value: 发票完整信息
```

## 日志输出

```
========== 开始优化版发票状态同步 ==========
数据库中待同步发票数量: 19856
同步类型: 未入账
涉及纳税人数量: 9
>>> [1/9] 开始查询纳税人 911100006259100634 的全量发票
>>> 纳税人 911100006259100634 查询到 2234 张发票
>>> [2/9] 开始查询纳税人 91210200604876695D 的全量发票
...
全量发票查询完成，共获取 19856 张发票
发票状态变化: 0400224130 23456789, 发票状态: 0->1, 勾选状态: null->01, 入账状态: null->02
...
========== 优化版发票状态同步完成 ==========
总处理数: 19856
状态已更新: 1234
状态未变化: 18500
未找到发票: 122
总耗时: 54 秒
==========================================
```

## 注意事项

1. **内存使用**：批量查询会将所有发票加载到内存中，确保服务器有足够内存
2. **API限流**：如果接口有限流，可能需要在纳税人之间添加延迟
3. **数据一致性**：查询和比对之间可能存在时间差，极少数情况下可能出现数据不一致

## 监控指标

- API调用次数
- 总耗时
- 状态更新数量
- 未找到发票数量（可能表示数据问题）

## 回滚方案

如果优化版本出现问题，可以快速回滚到旧版本：

```java
// 在 InvoiceCollectionScheduledTask 中修改
@Scheduled(cron = "0 0/30 * * * ?")
public void syncUnaccountedInvoices() {
    invoiceCollectionService.syncUnaccountedInvoicesOld(); // 使用旧版本
}
```
